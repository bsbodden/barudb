sequenceDiagram
    participant Client
    participant Memtable as LockFreeMemtable
    participant SkipMap as Crossbeam SkipMap
    participant Atomic as Atomic Counters

    %% Insert operation
    Client->>Memtable: put(key, value)
    activate Memtable
    
    Memtable->>SkipMap: contains_key(key)
    activate SkipMap
    SkipMap-->>Memtable: is_update (true/false)
    deactivate SkipMap
    
    alt is_update == false
        Memtable->>Memtable: check if buffer is full
        
        Memtable->>Atomic: update min/max key range
        activate Atomic
        Atomic-->>Memtable: updated
        deactivate Atomic
    end
    
    Memtable->>SkipMap: insert(key, value)
    activate SkipMap
    SkipMap-->>Memtable: previous value (if any)
    deactivate SkipMap
    
    alt is_update == false
        Memtable->>Atomic: current_size.fetch_add(1)
        activate Atomic
        Atomic-->>Memtable: incremented
        deactivate Atomic
    end
    
    Memtable-->>Client: Result (previous value or None)
    deactivate Memtable
    
    %% Get operation
    Client->>Memtable: get(key)
    activate Memtable
    
    Memtable->>Atomic: get key range (min_key, max_key)
    activate Atomic
    Atomic-->>Memtable: key range
    deactivate Atomic
    
    alt key is in range
        Memtable->>SkipMap: get(key)
        activate SkipMap
        SkipMap-->>Memtable: value or None
        deactivate SkipMap
    else key is outside range
        Memtable->>Memtable: optimize lookup (skip SkipMap)
    end
    
    Memtable-->>Client: Option<Value>
    deactivate Memtable
    
    %% Range query operation
    Client->>Memtable: range(start_key, end_key)
    activate Memtable
    
    Memtable->>SkipMap: range(start_key, end_key)
    activate SkipMap
    SkipMap-->>Memtable: Iterator over entries
    deactivate SkipMap
    
    Memtable->>Memtable: collect and sort results
    
    Memtable-->>Client: Vec<(Key, Value)>
    deactivate Memtable